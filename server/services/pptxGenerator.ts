import pptxgen from 'pptxgenjs';
import type { Slide } from '@shared/schema';
import fs from 'fs/promises';
import path from 'path';
import { randomUUID } from 'crypto';

interface PPTXGenerationOptions {
  templateStyle?: 'professional' | 'modern' | 'minimal';
  includeImages?: boolean;
  includeNotes?: boolean;
}

interface PPTXGenerationResult {
  filePath: string;
  fileName: string;
  fileSize: number;
}

export class PPTXGenerator {
  private outputDir: string;

  constructor(outputDir: string = './exports/pptx') {
    this.outputDir = outputDir;
  }

  /**
   * Generate a PowerPoint presentation from slide data
   */
  async generatePresentation(
    slides: Slide[],
    presentationTitle: string,
    options: PPTXGenerationOptions = {}
  ): Promise<PPTXGenerationResult> {
    if (!slides || slides.length === 0) {
      throw new Error('No slides provided for PPTX generation');
    }

    const {
      templateStyle = 'professional',
      includeImages = true,
      includeNotes = true
    } = options;

    try {
      console.log(`Generating PPTX with ${slides.length} slides using ${templateStyle} template`);

      // Create new presentation
      const pres = new pptxgen();

      // Set presentation properties
      pres.author = 'EchoDeck AI';
      pres.company = 'EchoDeck';
      pres.subject = presentationTitle;
      pres.title = presentationTitle;

      // Configure layout and theme based on template style
      this.configureTemplate(pres, templateStyle);

      // Add title slide
      await this.addTitleSlide(pres, presentationTitle, templateStyle);

      // Add content slides
      for (let i = 0; i < slides.length; i++) {
        const slide = slides[i];
        await this.addContentSlide(pres, slide, i + 1, {
          includeImages,
          includeNotes,
          templateStyle
        });
      }

      // Ensure output directory exists
      await fs.mkdir(this.outputDir, { recursive: true });

      // Generate file name and path
      const fileName = `${presentationTitle.replace(/[^a-zA-Z0-9]/g, '_')}_${randomUUID()}.pptx`;
      const filePath = path.join(this.outputDir, fileName);

      // Save presentation
      await pres.writeFile({ fileName: filePath });

      // Get file size
      const stats = await fs.stat(filePath);
      const fileSize = stats.size;

      console.log(`PPTX generated successfully: ${fileName} (${fileSize} bytes)`);

      return {
        filePath,
        fileName,
        fileSize
      };

    } catch (error) {
      console.error('PPTX generation failed:', error);
      throw new Error(`Failed to generate PPTX: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Configure presentation template and theme
   */
  private configureTemplate(pres: pptxgen, style: string): void {
    // Set slide size (16:9 aspect ratio)
    pres.defineLayout({ name: 'LAYOUT_16x9', width: 13.33, height: 7.5 });
    pres.layout = 'LAYOUT_16x9';

    // Define color schemes and fonts based on style
    const themes = {
      professional: {
        primaryColor: '1F4E79',
        secondaryColor: '70AD47',
        accentColor: 'FFC000',
        textColor: '2F2F2F',
        backgroundColor: 'FFFFFF',
        font: 'Calibri'
      },
      modern: {
        primaryColor: '2E86AB',
        secondaryColor: 'A23B72',
        accentColor: 'F18F01',
        textColor: '2A2A2A',
        backgroundColor: 'FAFAFA',
        font: 'Arial'
      },
      minimal: {
        primaryColor: '333333',
        secondaryColor: '666666',
        accentColor: '0073E6',
        textColor: '1A1A1A',
        backgroundColor: 'FFFFFF',
        font: 'Helvetica'
      }
    };

    // Apply theme (stored for use in slides)
    (pres as any).theme = themes[style as keyof typeof themes] || themes.professional;
  }

  /**
   * Add title slide to presentation
   */
  private async addTitleSlide(pres: pptxgen, title: string, style: string): Promise<void> {
    const slide = pres.addSlide();
    const theme = (pres as any).theme;

    // Add title
    slide.addText(title, {
      x: 1,
      y: 2.5,
      w: 11.33,
      h: 2,
      fontSize: 44,
      color: theme.primaryColor,
      bold: true,
      align: 'center',
      fontFace: theme.font
    });

    // Add subtitle
    slide.addText('Generated by EchoDeck AI', {
      x: 1,
      y: 4.5,
      w: 11.33,
      h: 1,
      fontSize: 20,
      color: theme.secondaryColor,
      align: 'center',
      fontFace: theme.font
    });

    // Add background color
    slide.background = { color: theme.backgroundColor };
  }

  /**
   * Add content slide with title, bullet points, and optional image
   */
  private async addContentSlide(
    pres: pptxgen,
    slideData: Slide,
    slideNumber: number,
    options: {
      includeImages: boolean;
      includeNotes: boolean;
      templateStyle: string;
    }
  ): Promise<void> {
    const slide = pres.addSlide();
    const theme = (pres as any).theme;

    // Set background
    slide.background = { color: theme.backgroundColor };

    // Add slide title
    slide.addText(slideData.title, {
      x: 0.5,
      y: 0.5,
      w: 12.33,
      h: 1,
      fontSize: 32,
      color: theme.primaryColor,
      bold: true,
      fontFace: theme.font
    });

    // Determine layout based on whether we have an image
    const hasImage = options.includeImages && slideData.imageUrl;
    const contentWidth = hasImage ? 6 : 11.33;
    const imageX = hasImage ? 7 : 0;

    // Add bullet points
    if (slideData.bulletPoints && slideData.bulletPoints.length > 0) {
      const bulletText = slideData.bulletPoints.map(point => ({ text: point, options: { bullet: true } }));
      
      slide.addText(bulletText, {
        x: 0.5,
        y: 2,
        w: contentWidth,
        h: 4.5,
        fontSize: 18,
        color: theme.textColor,
        fontFace: theme.font,
        lineSpacing: 32
      });
    }

    // Add image if available and enabled
    if (hasImage && slideData.imageUrl) {
      try {
        // For web URLs, pptxgenjs can handle them directly
        slide.addImage({
          path: slideData.imageUrl,
          x: imageX,
          y: 2,
          w: 5.5,
          h: 4,
          sizing: { type: 'contain', w: 5.5, h: 4 }
        });
      } catch (error) {
        console.warn(`Failed to add image to slide ${slideNumber}:`, error);
        // Add placeholder text instead
        slide.addText('Image not available', {
          x: imageX,
          y: 3.5,
          w: 5.5,
          h: 1,
          fontSize: 14,
          color: theme.secondaryColor,
          align: 'center',
          fontFace: theme.font,
          italic: true
        });
      }
    }

    // Add speaker notes if enabled
    if (options.includeNotes && slideData.speakerNotes) {
      slide.addNotes(slideData.speakerNotes);
    }
  }

  /**
   * Clean up old PPTX files to prevent disk space issues
   */
  async cleanupOldFiles(maxAgeHours: number = 24): Promise<void> {
    try {
      const files = await fs.readdir(this.outputDir);
      const cutoffTime = Date.now() - (maxAgeHours * 60 * 60 * 1000);

      for (const file of files) {
        if (file.endsWith('.pptx')) {
          const filePath = path.join(this.outputDir, file);
          const stats = await fs.stat(filePath);
          
          if (stats.mtime.getTime() < cutoffTime) {
            await fs.unlink(filePath);
            console.log(`Cleaned up old PPTX file: ${file}`);
          }
        }
      }
    } catch (error) {
      console.warn('Failed to cleanup old PPTX files:', error);
    }
  }
}

// Export singleton instance
export const pptxGenerator = new PPTXGenerator();